(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.UKATON = {}));
})(this, (function (exports) { 'use strict';

    // https://github.com/mrdoob/eventdispatcher.js/
    class EventDispatcher {
        addEventListener(type, listener) {
            if (this._listeners === undefined) this._listeners = {};

            const listeners = this._listeners;

            if (listeners[type] === undefined) {
                listeners[type] = [];
            }

            if (listeners[type].indexOf(listener) === -1) {
                listeners[type].push(listener);
            }
        }

        hasEventListener(type, listener) {
            if (this._listeners === undefined) return false;

            const listeners = this._listeners;

            return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
        }

        removeEventListener(type, listener) {
            if (this._listeners === undefined) return;

            const listeners = this._listeners;
            const listenerArray = listeners[type];

            if (listenerArray !== undefined) {
                const index = listenerArray.indexOf(listener);

                if (index !== -1) {
                    listenerArray.splice(index, 1);
                }
            }
        }

        dispatchEvent(event) {
            if (this._listeners === undefined) return;

            const listeners = this._listeners;
            const listenerArray = listeners[event.type];

            if (listenerArray !== undefined) {
                event.target = this;

                // Make a copy, in case listeners are removed while iterating.
                const array = listenerArray.slice(0);

                for (let i = 0, l = array.length; i < l; i++) {
                    array[i].call(this, event);
                }
            }
        }
    }

    const eventDispatcherAddEventListener = EventDispatcher.prototype.addEventListener;
    EventDispatcher.prototype.addEventListener = function (type, listener, options) {
        if (options) {
            if (options.once) {
                function onceCallback(event) {
                    listener.apply(this, arguments);
                    this.removeEventListener(type, onceCallback);
                }
                eventDispatcherAddEventListener.call(this, type, onceCallback);
            }
        } else {
            eventDispatcherAddEventListener.apply(this, arguments);
        }
    };

    class Logger {
        /**
         *
         * @param {boolean} isEnabled
         * @param {any} host
         * @param {string|undefined} suffix
         */
        constructor(isEnabled, host, suffix) {
            this.isEnabled = isEnabled;
            this.#host = host;
            this.#suffix = suffix;
        }

        isEnabled = true;
        /** @type {any} */
        #host;
        /** @type {string|undefined} */
        #suffix;

        /**
         *
         * @param {string} label
         * @param  {...any} rest
         */
        log(label, ...rest) {
            if (this.isEnabled) {
                console.groupCollapsed(
                    `[${this.#host.constructor.name}]${this.#suffix ? `(${this.#suffix})` : ""} - ${label}`
                );
                if (rest.length > 0) {
                    console.log(...rest);
                }
                console.trace(); // hidden in collapsed group
                console.groupEnd();
            }
        }
    }

    class Poll {
        logger = new Logger(false, this);

        /**
         *
         * @param {function():void} callback
         * @param {number} interval
         */
        constructor(callback, interval) {
            this.#callback = callback;
            this.#interval = interval;
        }

        /** @type {function():void} */
        #callback;
        /** @type {number} */
        #interval;
        /** @type {number|null} */
        #intervalId = null;

        get isRunning() {
            return this.#intervalId != null;
        }

        start() {
            if (!this.isRunning) {
                this.logger.log("starting poll");
                this.#intervalId = setInterval(() => this.#callback(), this.#interval);
            }
        }
        stop() {
            if (this.isRunning) {
                this.logger.log("stopping poll");
                clearInterval(this.#intervalId);
                this.#intervalId = null;
            }
        }
    }

    function check_is_iOS() {
        return (
            ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(
                navigator.platform
            ) ||
            // iPad on iOS 13 detection
            (navigator.userAgent.includes("Mac") && "ontouchend" in document)
        );
    }
    const is_iOS = check_is_iOS();

    /**
     * @param {object} message
     * @param {string} message.type
     */
    async function sendBackgroundMessage(message) {
        return Promise.resolve();
        //return browser.runtime.sendMessage(message);
    }

    /**
     * @param {function():void} callback
     */
    function addBackgroundListener(callback) {
        //browser.runtime.onMessage.addListener(callback);
    }

    /**
     * @param {function():void} callback
     */
    function removeBackgroundListener(callback) {
        //browser.runtime.onMessage.removeListener(callback);
    }

    class UKMission extends EventDispatcher {
        logger = new Logger(true, this);

        /** @type {UKDiscoveredDevice} */
        #discoveredDevice;

        /**
         * @param {UKDiscoveredDevice} discoveredDevice
         */
        constructor(discoveredDevice) {
            super();

            this.#discoveredDevice = discoveredDevice;

            this.logger.log("adding self");
            missionsManager.add(this);
        }

        destroy() {
            this.logger.log("destroying self");
            missionsManager.remove(this);
        }
    }

    /** @typedef {"motion module" | "left insole" | "right insole"} UKDeviceType */
    /** @typedef {"bluetooth" | "udp"} UKConnectionType */
    /** @typedef {"not connected" | "connecting" | "connected" | "disconnecting"} UKConnectionStatus */

    /**
     * @typedef DiscoveredDeviceInfo
     * @type {object}
     * @property {string} id
     * @property {string} name
     * @property {number} deviceType
     *
     * @property {number} timestampDifference
     * @property {number} rssi
     * @property {string|undefined} ipAddress
     *
     * @property {string} connectionStatus
     * @property {UKConnectionType|undefined} connectionType
     */

    class UKDiscoveredDevice {
        eventDispatcher = new EventDispatcher();

        /** @type {UKMission|undefined} */
        #mission;
        get mission() {
            return this.#mission;
        }

        #update(type, newValue) {
            this.logger.log(`updated ${type} to ${newValue}`);
            this.eventDispatcher.dispatchEvent({ type, message: { [type]: newValue } });
        }

        /** @type {string} */
        #id;
        get id() {
            return this.#id;
        }
        #updateId(newValue) {
            if (this.#id != newValue) {
                this.#id = newValue;
                this.#update("id", newValue);
            }
        }

        /** @type {string} */
        #name;
        get name() {
            return this.#name;
        }
        #updateName(newValue) {
            if (this.#name != newValue) {
                this.#name = newValue;
                this.#update("name", newValue);
            }
        }

        /** @type {UKDeviceType} */
        #deviceType;
        get deviceType() {
            return this.#deviceType;
        }
        /** @param {UKDeviceType} newValue */
        #updateDeviceType(newValue) {
            if (this.#deviceType != newValue) {
                this.#deviceType = newValue;
                this.#update("deviceType", newValue);
            }
        }

        /** @type {number} */
        #rssi;
        get rssi() {
            return this.#rssi;
        }
        /** @param {number} newValue */
        #updateRssi(newValue) {
            if (this.#rssi != newValue) {
                this.#rssi = newValue;
                this.#update("rssi", newValue);
            }
        }

        /** @type {number} */
        #timestampDifference;
        get timestampDifference() {
            return this.#timestampDifference;
        }
        /** @param {number} newValue */
        #updateTimestampDifference(newValue) {
            if (this.#timestampDifference != newValue) {
                this.#timestampDifference = newValue;
                this.#update("timestampDifference", newValue);
            }
        }

        /** @type {string|undefined} */
        #ipAddress;
        get ipAddress() {
            return this.#ipAddress;
        }
        /** @param {string} newValue */
        #updateIpAddress(newValue) {
            if (this.#ipAddress != newValue) {
                this.#ipAddress = newValue;
                this.#update("ipAddress", newValue);
            }
        }
        get isConnectedToWifi() {
            return Boolean(this.ipAddress);
        }

        /** @type {UKConnectionStatus|undefined} */
        #connectionStatus;
        get connectionStatus() {
            return this.#connectionStatus;
        }
        /** @param {UKConnectionStatus|undefined} newValue */
        #updateConnectionStatus(newValue) {
            if (this.#connectionStatus != newValue) {
                this.#connectionStatus = newValue;
                if (newValue == "connected" || newValue == "not connected") {
                    this.#connectionStatusPoll.stop();
                }

                if (newValue == "connected") {
                    this.#mission = new UKMission(this);
                } else if (newValue == "not connected" && this.#mission) {
                    this.#mission.destroy();
                    this.#mission = undefined;
                }

                this.#update("connectionStatus", newValue);
            }
        }
        get isConnected() {
            return this.connectionStatus == "connected";
        }

        /** @type {UKConnectionType|undefined} */
        #connectionType;
        get connectionType() {
            return this.#connectionType;
        }
        /** @param {UKConnectionType} newValue */
        #updateConnectionType(newValue) {
            if (this.#connectionType != newValue) {
                this.#connectionType = newValue;
                this.#update("connectionType", newValue);
            }
        }

        /**
         * @param {DiscoveredDeviceInfo} discoveredDeviceInfo
         */
        constructor(discoveredDeviceInfo) {
            this.logger = new Logger(false, this, discoveredDeviceInfo.id);
            this.update(discoveredDeviceInfo);

            this.#boundOnBackgroundMessage = this.#onBackgroundMessage.bind(this);
            addBackgroundListener(this.#boundOnBackgroundMessage);
        }

        /**
         * @param {DiscoveredDeviceInfo} discoveredDeviceInfo
         */
        update(discoveredDeviceInfo) {
            const { id, name, deviceType, rssi, timestampDifference, ipAddress, connectionStatus, connectionType } =
                discoveredDeviceInfo;

            this.#updateId(id);
            this.#updateName(name);
            this.#updateDeviceType(deviceType);

            this.#updateRssi(rssi);
            this.#updateTimestampDifference(timestampDifference);

            this.#updateIpAddress(ipAddress);

            this.#updateConnectionStatus(connectionStatus);
            this.#updateConnectionType(connectionType);

            this.logger.log(`updated discovered device ${id}`, discoveredDeviceInfo);
        }

        /**
         *
         * @param {object} message
         * @param {string} message.type
         */
        async #sendBackgroundMessage(message) {
            Object.assign(message, { id: this.id });
            return sendBackgroundMessage();
        }

        #connectionStatusPoll = new Poll(this.#checkConectionStatus.bind(this), 200);
        async #checkConectionStatus() {
            await this.#sendBackgroundMessage({ type: "connectionStatus" });
        }

        /**
         * @param {UKConnectionType} connectionType
         */
        async connect(connectionType = "bluetooth") {
            if (this.connectionStatus == "connected") {
                this.logger.log("can't connect - already connected");
                return;
            }
            if (connectionType != "bluetooth" && is_iOS) {
                this.logger.log(`unable to connect via ${connectionType} on iOS - changing to bluetooth`);
                connectionType = "bluetooth";
            }
            await this.#sendBackgroundMessage({ type: "connect", connectionType });
            this.#connectionStatusPoll.start();
        }
        async disconnect() {
            if (this.connectionStatus == "not connected") {
                this.logger.log("can't disconnect - not connected");
                return;
            }
            await this.#sendBackgroundMessage({ type: "disconnect" });
            this.#connectionStatusPoll.start();
        }

        /**
         * @param {object} message
         * @param {string} message.type
         */
        #onBackgroundMessage(message) {
            if (message.id != this.id) {
                return;
            }

            this.logger.log(`received background message of type ${message.type}`, message);
            switch (message.type) {
                case "connectionStatus":
                    this.#updateConnectionStatus(message.connectionStatus);
                    this.#updateConnectionType(message.connectionType);
                    break;
                default:
                    this.logger.log(`uncaught message type ${message.type}`);
                    break;
            }
        }
        /** @type {function} */
        #boundOnBackgroundMessage;

        destroy() {
            this.logger.log(`destroying self`);
            this.#connectionStatusPoll.stop();
            removeBackgroundListener(this.#boundOnBackgroundMessage);
        }
    }

    class UKBluetoothManager {
        logger = new Logger(false, this);
        eventDispatcher = new EventDispatcher();

        static #shared = new UKBluetoothManager();
        static get shared() {
            return this.#shared;
        }

        #isScanning = false;
        get isScanning() {
            return this.#isScanning;
        }
        set isScanning(newValue) {
            if (this.#isScanning != newValue) {
                this.#isScanning = newValue;
                this.#isScanningPoll.stop();

                this.logger.log(`updated isScanning to ${this.isScanning}`);
                this.eventDispatcher.dispatchEvent({
                    type: "isScanning",
                    message: { isScanning: this.isScanning },
                });

                if (this.isScanning) {
                    this.#discoveredDevicesPoll.start();
                } else {
                    this.#discoveredDevicesPoll.stop();
                }
            }
        }

        /**
         * @param {object} message
         * @param {string} message.type
         */
        async #sendBackgroundMessage(message) {
            return sendBackgroundMessage();
        }

        async checkIsScanning() {
            const response = await this.#sendBackgroundMessage({ type: "isScanning" });
            const { isScanning } = response;
            this.logger.log(`isScanning response: ${isScanning}`, response);
            this.isScanning = isScanning;
        }

        #isScanningPoll = new Poll(this.checkIsScanning.bind(this), 100);

        async setScan(newValue) {
            if (newValue != this.isScanning) {
                const response = await this.#sendBackgroundMessage({ type: "setScan", newValue });
                const { isScanning } = response;
                this.logger.log(`setScan response: ${isScanning}`, response);
                if (isScanning == newValue) {
                    this.isScanning = isScanning;
                } else {
                    this.#isScanningPoll.start();
                }
            } else {
                this.logger.log("redundant setScan");
            }
        }
        async toggleScan() {
            return this.setScan(!this.isScanning);
        }

        #discoveredDevicesPoll = new Poll(this.checkDiscoveredDevices.bind(this), 200);
        async checkDiscoveredDevices() {
            const response = await this.#sendBackgroundMessage({ type: "discoveredDevices" });
            const { discoveredDevices: discoveredDeviceInfo } = response;
            this.logger.log(`discovered ${discoveredDeviceInfo.length} devices`, response);
            this.#updateDiscoveredDevices(discoveredDeviceInfo);
        }

        /** @type {Object.<string, UKDiscoveredDevice>} */
        #discoveredDevices = {};
        get discoveredDevices() {
            return this.#discoveredDevices;
        }

        /**
         * @typedef {import('./UKDiscoveredDevice.js').DiscoveredDeviceInfo} DiscoveredDeviceInfo
         */

        /**
         *
         * @param {[DiscoveredDeviceInfo]} discoveredDevicesInfo
         */
        #updateDiscoveredDevices(discoveredDevicesInfo) {
            const idsToDelete = new Set(Object.keys(this.#discoveredDevices));
            discoveredDevicesInfo.forEach((discoveredDeviceInfo) => {
                const { id } = discoveredDeviceInfo;

                if (idsToDelete.has(id)) {
                    idsToDelete.delete(id);
                    const discoveredDevice = this.#discoveredDevices[id];
                    discoveredDevice.update(discoveredDeviceInfo);
                } else {
                    const discoveredDevice = new UKDiscoveredDevice(discoveredDeviceInfo);
                    this.#discoveredDevices[id] = discoveredDevice;
                    this.eventDispatcher.dispatchEvent({
                        type: "discoveredDeviceAdded",
                        message: { discoveredDevice },
                    });
                }
            });
            idsToDelete.forEach((id) => {
                const discoveredDevice = this.#discoveredDevices[id];
                discoveredDevice.destroy();
                delete this.#discoveredDevices[id];
                this.eventDispatcher.dispatchEvent({
                    type: "discoveredDeviceRemoved",
                    message: { discoveredDevice },
                });
            });

            this.eventDispatcher.dispatchEvent({
                type: "discoveredDevices",
                message: { discoveredDevices: this.discoveredDevices },
            });
        }

        /** @type {[UKMission]} */
        devices = [];

        /** UKBluetoothManager is a singleton - use UKBluetoothManager.shared */
        constructor() {
            if (this.shared) {
                throw new Error("UKBluetoothManager is a singleton - use UKBluetoothManager.shared");
            }

            window.addEventListener("unload", () => {
                this.setScan(false);
            });

            addBackgroundListener(this.#onBackgroundMessage.bind(this));

            this.checkIsScanning();
            this.checkDiscoveredDevices();
        }

        /**
         * @param {object} message
         * @param {string} message.type
         */
        #onBackgroundMessage(message) {
            this.logger.log(`received background message of type ${message.type}`, message);

            switch (message.type) {
                case "isScanning":
                    this.isScanning = message.isScanning;
                    break;
                case "discoveredDevices":
                    this.#updateDiscoveredDevices(message.discoveredDevices);
                    break;
                default:
                    this.logger.log(`uncaught message type ${message.typs}`);
                    break;
            }
        }
    }

    var bluetoothManager = UKBluetoothManager.shared;

    class UKMissionsManager {
        logger = new Logger(true, this);
        eventDispatcher = new EventDispatcher();

        static #shared = new UKMissionsManager();
        static get shared() {
            return this.#shared;
        }

        /** @type {[UKMission]} */
        #missions = [];
        get missions() {
            return this.#missions;
        }

        /** UKMissionsManager is a singleton - use UKMissionsManager.shared */
        constructor() {
            if (this.shared) {
                throw new Error("UKMissionsManager is a singleton - use UKMissionsManager.shared");
            }
        }

        /**
         *
         * @param {UKMission} mission
         */
        add(mission) {
            if (!this.#missions.includes(mission)) {
                this.#missions.push(mission);
                this.logger.log("added mission", mission);

                this.eventDispatcher.dispatchEvent({ type: "addedMission", message: { mission } });
                this.eventDispatcher.dispatchEvent({ type: "missions", message: { mission: this.missions } });
            } else {
                this.logger.log("already has mission", mission);
            }
        }

        /**
         *
         * @param {UKMission} mission
         */
        remove(mission) {
            if (this.#missions.includes(mission)) {
                this.#missions.splice(this.#missions.indexOf(mission), 1);
                this.logger.log("removed mission", mission);

                this.eventDispatcher.dispatchEvent({ type: "removedMission", message: { mission } });
                this.eventDispatcher.dispatchEvent({ type: "missions", message: { mission: this.missions } });
            } else {
                this.logger.log("mission not found", mission);
            }
        }
    }

    var missionsManager = UKMissionsManager.shared;

    const UkatonKit = { bluetoothManager, missionsManager };

    window.UkatonKit = UkatonKit;

    exports.bluetoothManager = bluetoothManager;
    exports.missionsManager = missionsManager;

}));
